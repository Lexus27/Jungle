Collection
==========
----------

Коллекция, сопоставима многим субъектам программной модели, благодаря определению общего интерфейса коллекций
можно добится стандартизирования всех процессов над коллекциями, и в разы уменьшив отвлекающий от основных целей
фактор при программировании целевых компонентов.


#Доступ к елементу коллекции по числу(индексированные).
Пример Jungle\XPlate\HTML\Element у которого есть набор дочерних элементов, операции над которым тривиальны за исключением 
дополнительного целевого(уже будучи расширенного) функционала по перечислению дочерних HTML элементов.

#Доступ к елементу по ключу (ассоциирование значения в наборе):
Такие коллекции разумнее ближе называть регистрами ```Registry```,
к регистрам я отношу данные типа ```Key => Value```,
Это так-же может быть и объект представления данных @DataMapping который обеспечивает доступ к значениям полей по названию поля
```Registry``` и ```DataMapping```, вещи весьма разные по семантике,
первый же будет вести себя как стек данных или хранилище.
второй же будет описывать значения полей какого-то объекта данных

##Я отвел 2 типа для индексирования значений по ключу:

<b><i>PreNamed</i></b>(пре-именованые): значения это когда само значение незнает о том как его находят в содержимой коллекции по ключу.
      Это привычный тип именования в PHPМассивах ```['key' => Value]```
     Где key и является именем значения в массиве.

Поиск ключа в таких наборах обычный: ```$array['key']```
      
<b><i>SelfNamed</i></b>(само-именованые): значения содержат ключ в себе , в таком случае значениями могут быть только ```Jungle\Basic\INamed``` производные объекты
      Это тот тип который помогает сохранить целостность соотношения (Имя - Поведение)
     и исключает утерю ключа на значение или значения от ключа , привычным для массивов способов
      Хранятся такие объекты в коллекции путем содержания ИНДЕКСНОГО массива в котором будет набор объектов где
     доступ к ключу будет производится посредством вызова метода getName, преимущество такого объекта в том что он может 
     без проблем иметь доступ к своему ключу и все другие части программы связаны только с 1 ячейкой памяти при 
     идентификации объекта по ключу, мы можем рендерить имя объекта через __toString объекта и использовать объект ровно 
     как строку в конкатенациях) тоесть объект сам по себе идет как ключ (в связке с __toString)
     
     ['key'] = value
          ИЛИ
     [0] = o:key_value ((
            $o->getValue() || 
            $o->process() || 
            $o->getBehaviour()
        ) || (
            $o->getName() || 
            "Hello " . $o . ".!!"
        ) 
     )
     
     
Поиск ключа в таких наборах : 

    /** @var INamed[] */
    protected $collection = [];
    
    public function getItem($name){
        foreach($this->collection as $object){
            if($object->getName() === $name){ // Или strcasecmp($object->getName(),$name)===0
                return $object;
            }
        }
        return null;
    }
    
    
    

----


	Registry:
	['option1'] 		= null;
	['option2'] 		= null;
	['config3'] 		= null;
	['config4'] 		= null;
	['service_key']		= null;
	 
DataMapping в принципе это тоже самое.




###Коллекции бывают
----------------
    
####Определение порядка



1. Наборы элементов без контроля порядка, важно только присутствие элементов <br/>
```add, search, removeNode```
 
2. Наборы элементов раставленные в определенном порядке, важен порядок от начала к концу<br/>
```append, prepend, insert, replace, splice```

    dataA. Сортируемые наборы ```sort, sortBy, setDefaultSorter(callable $sorter = null)```
    
####Тип поиска по ключу



1. Наборы с индексными ключами <br/>
```$collection[o]```

    1.1 Наборы с индексными ключами и ```INamed``` значениями<br/>
    ```$collection[o]=INamed```

1. Наборы с ассоциативными ключами<br/>
```$collection['key']```


####Организация наборов

1. Спецификация<b>[INamed.key]</b> - Описание определений, CSS\Definition где ключем является Css\Property объект производный INamed
2. Стек<b>[I]</b>         - Организация линейной последовательности при итерациях где важен порядок
3. Хранилище<b>[I,N,INamed]</b>    - Организация простого контейнера для хранения элементов, где не важна последовательность, но важна уникальность

####Конкретные

1. Хранилище <b>[i => INamed]</b> - Набор производных от INamed (с указанием предка)
2. Спецификация <b>[INamed => Value]</b> - Набор значению идентифицирующихся по INamed ключу (с указанием предка)